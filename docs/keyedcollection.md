# db_constraints.keyed.keyedcollection

[](Generated by Ddoc from source/db_constraints/keyed/keyedcollection.d)

The keyedcollection module contains:
  + [usableForKeyedCollection](#usableForKeyedCollection)
  + [BaseKeyedCollection](#BaseKeyedCollection)
  + [KeyedCollection](#KeyedCollection)

**License:**
[GPL-2.0](https://github.com/marmy28/db_constraints/blob/master/LICENSE)


**Authors:**
Matthew Armbruster


**Source:** [source/db_constraints/keyed/keyedcollection.d](https://github.com/marmy28/db_constraints/tree/master/source/db_constraints/keyed/keyedcollection.d)



***

<a id="usableForKeyedCollection"></a>
```d
enum usableForKeyedCollection(alias T);

```


***

<a id="BaseKeyedCollection"></a>
```d
class BaseKeyedCollection(T) if (usableForKeyedCollection!T);

```

Turns the inheriting class into a base keyed collection.
The key is based on the singular class' clustered index.
The requirements (except for dup) are taken care of when
you include the keyeditem in the _T_ class.

Parameters |
---|
*T*|
&nbsp;&nbsp;&nbsp;&nbsp;the singular class|



***

<a id="KeyedCollection"></a>
```d
template KeyedCollection(T) if (usableForKeyedCollection!T)
```

Turns the inheriting class into a base keyed collection.
The key is based on the singular class' clustered index.
The requirements (except for dup) are taken care of when
you include the keyeditem in the _T_ class.

Parameters |
---|
*T*|
&nbsp;&nbsp;&nbsp;&nbsp;the singular class|


**Examples:**


```d

// singular class
class Candy
{
private:
    string _name;
    int _ranking;
    int _annualSales;
    string _brand;
public:
    // marking name as part of the primary key
    @PrimaryKeyColumn @NotNull
    @property string name() const nothrow pure @safe @nogc
    {
        return _name;
    }
    @property void name(string value)
    {
        setter(_name, value);
    }
    @property int ranking() const nothrow pure @safe @nogc
    {
        return _ranking;
    }
    // making sure that ranking will always be above 0
    @CheckConstraint!(a => a > 0, "chk_Candys_ranking")
    @property void ranking(int value)
    {
        setter(_ranking, value);
    }

    this(string name, immutable(int) ranking, immutable(int) annualSales, string brand)
    {
        this._name = name;
        this._ranking = ranking;
        this._annualSales = annualSales;
        this._brand = brand;
        // need to initialize the keyed item
        initializeKeyedItem();
    }
    Candy dup() const
    {
        return new Candy(this._name, this._ranking, this._annualSales, this._brand);
    }
    // the default is to make the primary key into the clustered index
    // which allows you to search based on the primary key
    mixin KeyedItem!();
}

// plural class
// I am using an alias since BaseKeyedCollection
// takes care of everything I want to do for this example.
alias Candies = BaseKeyedCollection!(Candy);

// source: http://www.bloomberg.com/ss/09/10/1021_americas_25_top_selling_candies/
auto milkyWay = new Candy("Milkey Way", 18, 129_000_000, "Mars");
// should be Milky not Milkey, this is wrong on purpose
auto snickers = new Candy("Snickers", 4, 441_100_000, "Mars");
auto reesesPBCups = new Candy("Reese's Peanut Butter Cups", 2, 516_500_000, "Hershey");

auto mars = new Candies([milkyWay, snickers]);
assert(mars.length == 2);
assert(!mars.containsChanges);

// use the class as an index
assert(mars[milkyWay] is milkyWay);
// use the primary key as an index
auto pk = Candy.PrimaryKey("Milkey Way");
assert(mars[pk] is milkyWay);
// use the contents of the primary key as an index
assert(mars["Milkey Way"] is milkyWay);

// milky way is in mars
assert(mars.contains(pk));
// reesesPBCups is not in mars
assert(!mars.contains(reesesPBCups));

// now we change the name to be correct
mars[pk].name = "Milky Way";
assert(mars.containsChanges);

// since we had name in pk spelled incorrectly
// and changed it, the primary key in mars has
// updated so Milkey Way is no longer in it but
// Milky Way is.
assert(!mars.contains("Milkey Way"));
assert(mars.contains("Milky Way"));

foreach(name_pk, candy; mars)
{
    assert(mars[name_pk] == candy);
}

// trying to add another candy with the same name will
// result in a unique constraint violation
auto milkyWay2 = new Candy("Milky Way", 18, 0, null);
import std.exception : assertThrown;
assertThrown!(UniqueConstraintException)(mars ~= milkyWay2);

// ranking has a check constraint saying ranking always must be greater
// than 0. setting it to -1 resolves in a CheckConstraintException.
assertThrown!(CheckConstraintException)(mars["Milky Way"].ranking = -1);
// Since name is part of the primary key we must mark it with NotNull
// trying to set this to null will result in a CheckConstraintException.
assertThrown!(CheckConstraintException)(mars["Milky Way"].name = null);

// violatesUniqueConstraints will tell you which constraint is violated if any
string violatedConstraint;
assert(mars.violatesUniqueConstraints(milkyWay2, violatedConstraint));
assert(violatedConstraint !is null && violatedConstraint == "PrimaryKey");

// removing milky way from mars
mars.remove("Milky Way");
// this means milkyWay2 is no longer a duplicate
assert(!mars.violatesUniqueConstraints(milkyWay2, violatedConstraint));
assert(violatedConstraint is null);

```

***

<a id="KeyedCollection.key_type"></a>
```d
alias key_type = typeof(T.key);

```

The key type is alias'd at the type since it looked better than having
typeof(T.key) everywhere.


***

<a id="KeyedCollection.itemChanged"></a>
```d
void itemChanged(string propertyName, key_type item_key);

```

itemChanged is connected to the signal emitted by the item. This checks
constraints and makes sure the changes are acceptable.


***

<a id="KeyedCollection.markAsSaved"></a>
```d
final pure nothrow @nogc void markAsSaved();

```

Changes `this` to not contain changes. Should only
be used after a save.


***

<a id="KeyedCollection.containsChanges"></a>
```d
final const pure nothrow @nogc @property @safe bool containsChanges();

```

Read-only property telling if `this` contains changes.

**Returns:**
true if `this` contains changes.


***

<a id="KeyedCollection.enforceConstraints"></a>
```d
final pure nothrow @nogc @property @safe void enforceConstraints(bool value);

```

Setter to enforce the constraints. By default
this is true but you may set it to false if you have a lot of
initial data and already trust that is unique and accurate.


Setting this to false means that there are no checks and if there
is a duplicate clustered index, it will be overwritten.


***

<a id="KeyedCollection.notify"></a>
```d
final void notify()(string propertyName, key_type item_key);

```

Notifies `this` which property changed.
This also emits a signal with the property name that changed.

Parameters |
---|
*string propertyName*|
&nbsp;&nbsp;&nbsp;&nbsp;the property name that changed|
*key_type item_key*|
&nbsp;&nbsp;&nbsp;&nbsp;the items key that changed|



***

<a id="KeyedCollection.remove"></a>
```d
final void remove(key_type item_key, Flag!"notifyChange" notifyChange = Yes.notifyChange);

final void remove(T item);

final void remove(A...)(A a);

```

Removes an item from `this` and disconnects the signals. Notifies
that the length of `this` has changed.


***

<a id="KeyedCollection.add"></a>
```d
final void add(T item, Flag!"notifyChange" notifyChange = Yes.notifyChange);

<a id="KeyedCollection.this"></a>
```d
final this(T item);

<a id="KeyedCollection.opOpAssign"></a>
```d
final ref auto opOpAssign(string op : "~")(T item);

```

Adds `item` to `this` and connects to the signals emitted by `item`.
Notifies that the length of `this` has changed.

Parameters |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want to add to `this`|
*Flag!"notifyChange" notifyChange*|
&nbsp;&nbsp;&nbsp;&nbsp;whether or not to emit this change. Should only be No if coming from itemChanged|

:exclamation: **Throws:**
UniqueConstraintException if `this` already contains `item` and
    enforceConstraints is true.

:exclamation: **Throws:**
CheckConstraintException if the item is violating any of its
    defined check constraints and enforceConstraints is true.

:exclamation: **Throws:**
ForeignKeyException if the item is violating any of its
    foreign key constraints and enforceConstraints is true.
**Precondition:** 
```d
assert(items !is null);
```


***

<a id="KeyedCollection.add.2"></a>
```d
final void add(I)(I items) if (isIterable!I);

<a id="KeyedCollection.this.2"></a>
```d
final this(I)(I items) if (isIterable!I);

<a id="KeyedCollection.opOpAssign.2"></a>
```d
final ref auto opOpAssign(string op : "~", I)(I items) if (isIterable!I);

```

Does the same as `add(T item)` but for an array.


**Precondition:** 
```d
assert(items !is null);
```


***

<a id="KeyedCollection.opIndex"></a>
```d
final inout ref inout(T) opIndex(in T item);

```

Gets the approriate `T` that equals `item`.

Parameters |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want back from the collection|

**Returns:**
The item in the collection that matches `item`.

:exclamation: **Throws:**
KeyedException if `this` does not contain a matching clustered index.


***

<a id="KeyedCollection.opIndex.2"></a>
```d
final inout ref inout(T) opIndex(in key_type clIdx);

```

Gets the approriate `T` that has clustered index `clIdx`.

Parameters |
---|
*key_type clIdx*|
&nbsp;&nbsp;&nbsp;&nbsp;the clustered index of the item you want back|

**Returns:**
The item in the collection that has clustered index `clIdx`.

:exclamation: **Throws:**
KeyedException if `this` does not contain a matching clustered index.


***

<a id="KeyedCollection.opIndex.3"></a>
```d
final inout ref inout(T) opIndex(A...)(in A a);

```

Gets the approriate `T` that has clustered index `a`.

Parameters |
---|
*A a*|
&nbsp;&nbsp;&nbsp;&nbsp;the fields of the clustered index of the item you want back.|

**Returns:**
The item in the collection that has the clustered index with fields `a`.

:exclamation: **Throws:**
KeyedException if `this` does not contain a matching clustered index.


***

<a id="KeyedCollection.opDispatch"></a>
```d
auto opDispatch(string name, A...)(A a);

```

Forwards all methods not specified by this abstract class
to the private associative array.


***

<a id="KeyedCollection.opApply"></a>
```d
final int opApply(int delegate(ref T) dg);

final int opApply(int delegate(key_type, ref T) dg);

```

Allows you to use `this` in a foreach loop.


***

<a id="KeyedCollection.length"></a>
```d
final const pure nothrow @property @safe size_t length();

```

Gets the length of the collection.

**Returns:**
The number of items in the collection.


***

<a id="KeyedCollection.contains"></a>
```d
final const pure nothrow @nogc @safe bool contains(in T item);

<a id="KeyedCollection.opBinaryRight"></a>
```d
inout pure nothrow @nogc @safe inout(T)* opBinaryRight(string op : "in")(in T item);

```

Checks if `item` is in the collection.

Parameters |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want to see is in the collection|

**Returns:**
true if `item` is in the collection.


***

<a id="KeyedCollection.contains.2"></a>
```d
final const pure nothrow @nogc @safe bool contains(in key_type clIdx);

<a id="KeyedCollection.opBinaryRight.2"></a>
```d
final inout pure nothrow @nogc @safe inout(T)* opBinaryRight(string op : "in")(in key_type clIdx);

```

Checks if `clIdx` is in the collection.

Parameters |
---|
*key_type clIdx*|
&nbsp;&nbsp;&nbsp;&nbsp;the clustered index of the item you want to see is in the collection|

**Returns:**
true if there is a clustered index in the collection that
    matches `clIdx`.


***

<a id="KeyedCollection.contains.3"></a>
```d
final const pure nothrow @nogc @safe bool contains(A...)(in A a);

<a id="KeyedCollection.opBinaryRight.3"></a>
```d
final inout pure nothrow @nogc @safe inout(T)* opBinaryRight(string op : "in", A...)(in A a);

```

Checks if `a` makes a clustered index that is in the collection.

Parameters |
---|
*A a*|
&nbsp;&nbsp;&nbsp;&nbsp;the fields of the clustered index of the item you want to see is in the collection|

**Returns:**
true if there is a clustered index in the collection that
    matches `a`.


***

<a id="KeyedCollection.violatesUniqueConstraints"></a>
```d
final const pure nothrow bool violatesUniqueConstraints(in T item, out string constraintName);

```

Checks if the item has any conflicting unique constraints. This
is more extensive than `contains`.


**Precondition:** 
```d
assert(items !is null);
```
**Postcondition:**

```d
if (result)
    assert(constraintName !is null && constraintName != "");
else
    assert(constraintName is null);

```






Copyright :copyright: 2015 | Page generated by [Ddoc](http://dlang.org/ddoc.html) on Sat Oct 10 10:04:12 2015

