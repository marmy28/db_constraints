# db_constraints.keyed.keyedcollection
Generated by Ddoc from source/db_constraints/keyed/keyedcollection.d

***
```d
class BaseKeyedCollection(T) if (hasMember!(T, "dup") && hasMember!(T, "key") && hasMember!(T, "emitChange") && hasMember!(T, "checkConstraints") && hasMember!(T, "UniqueConstraintStructNames"));

```
**Summary:**
Turns the inheriting class into a base keyed collection.
The key is based on the singular class' clustered index.
The requirements (except for dup) are taken care of when
you include the keyeditem in the *T* class.

Params |
---|
*T*|
&nbsp;&nbsp;&nbsp;&nbsp;the singular class.|

**Examples:**
```d

// singular class
class Candy
{
private:
    string _name;
    int _ranking;
    int _annualSales;
    string _brand;
public:
    // marking name as part of the primary key
    @PrimaryKeyColumn
    string name() const @property nothrow pure @safe @nogc
    {
        return _name;
    }
    void name(string value) @property
    {
        setter(_name, value);
    }
    int ranking() const @property nothrow pure @safe @nogc
    {
        return _ranking;
    }
    void ranking(int value) @property
    {
        setter(_ranking, value);
    }
    @NotNull
    int annualSales() const @property nothrow pure @safe @nogc
    {
        return _annualSales;
    }
    void annualSales(int value) @property
    {
        setter(_annualSales, value);
    }
    string brand() const @property nothrow pure @safe @nogc
    {
        return _brand;
    }
    // this can only be Mars or Hershey
    @NotNull
    @CheckConstraint!((a) => a == "Mars" || a == "Hershey")
    void brand(string value) @property
    {
        setter(_brand, value);
    }

    this(string name, immutable(int) ranking, immutable(int) annualSales, string brand)
    {
        this._name = name;
        this._ranking = ranking;
        this._annualSales = annualSales;
        this._brand = brand;
        // need to initialize the keyed item
        initializeKeyedItem();
    }
    Candy dup() const
    {
        return new Candy(this._name, this._ranking, this._annualSales, this._brand);
    }
    // the default is to make the primary key into the clustered index
    // which allows you to search based on the primary key
    mixin KeyedItem!(typeof(this));
}

// plural class
// I am using an alias since BaseKeyedCollection
// takes care of everything I want to do for this example.
alias Candies = BaseKeyedCollection!(Candy);

// source: http://www.bloomberg.com/ss/09/10/1021_americas_25_top_selling_candies/
auto milkyWay = new Candy("Milkey Way", 18, 129_000_000, "Mars");
// should be Milky not Milkey, this is wrong on purpose
auto snickers = new Candy("Snickers", 4, 441_100_000, "Mars");
auto reesesPBCups = new Candy("Reese's Peanut Butter Cups", 2, 516_500_000, "Hershey");

auto mars = new Candies([milkyWay, snickers]);
assert(mars.length == 2);
assert(!mars.containsChanges);

// use the class as an index
assert(mars[milkyWay] is milkyWay);
// use the primary key as an index
auto pk = Candy.PrimaryKey("Milkey Way");
assert(mars[pk] is milkyWay);
// use the contents of the primary key as an index
assert(mars["Milkey Way"] is milkyWay);

// milky way is in mars
assert(mars.contains(pk));
// reesesPBCups is not in mars
assert(!mars.contains(reesesPBCups));

// now we change the name to be correct
mars[pk].name = "Milky Way";
assert(mars.containsChanges);

// since we had name in pk spelled incorrectly
// and changed it, the primary key in mars has
// updated so Milkey Way is no longer in it but
// Milky Way is.
assert(!mars.contains("Milkey Way"));
assert(mars.contains("Milky Way"));

foreach(name_pk, candy; mars)
{
    assert(mars[name_pk] == candy);
}

// trying to add another candy with the same name will
// result in a unique constraint violation
auto milkyWay2 = new Candy("Milky Way", 0, 0, "Mars");
import std.exception : assertThrown;
assertThrown!(UniqueConstraintException)(mars ~= milkyWay2);

// trying to change the brand name to something other than
// Mars or Hershey will result in a check constraint violation
// since we marked brand with a check constraint
assertThrown!(CheckConstraintException)(mars["Milky Way"].brand = "Cars");
assertThrown!(CheckConstraintException)(mars["Milky Way"].brand = null);

// violatesUniqueConstraints will tell you which constraint is violated if any
auto violatedConstraint = "";
assert(mars.violatesUniqueConstraints(milkyWay2, violatedConstraint));
assert(violatedConstraint == "PrimaryKey");

// removing milky way from mars
mars.remove("Milky Way");
// this means milkyWay2 is no longer a duplicate
assert(!mars.violatesUniqueConstraints(milkyWay2, violatedConstraint));
assert(violatedConstraint == "");


``` 
***
```d
alias key_type = typeof(T.key);

```
**Summary:**
The key type is alias'd at the type since it looked better than having
typeof(T.key) everywhere.
 

***
```d
void itemChanged(string propertyName, key_type item_key);

```
**Summary:**
itemChanged is connected to the signal emitted by the item. This checks
constraints and makes sure the changes are acceptable.
 

***
```d
pure nothrow @nogc @safe void markAsSaved();

```
**Summary:**
Changes this to not contain changes. Should only
be used after a save.
 

***
```d
const pure nothrow @nogc @property @safe bool containsChanges();

```
**Summary:**
Read-only property telling if this contains changes.

**Returns:**
true if this contains changes.
 

***
```d
const pure nothrow @nogc @property @safe bool enforceConstraints();
pure nothrow @nogc @property @safe void enforceConstraints(bool value);

```
**Summary:**
Getter and setter to enforce the constraints. By default
this is true but you may set it to false if you have a lot of
initial data and already trust that is unique and accurate.

**Description:**
Setting this to false means that there are no checks and if there
is a duplicate clustered index, it will be overwritten.
 

***
```d
void notify(string propertyName, key_type item_key = key_type.init);

```
**Summary:**
Notifies this which property changed.
This also emits a signal with the property name that changed.

Params |
---|
*string propertyName*|
&nbsp;&nbsp;&nbsp;&nbsp;the property name that changed.|

 

***
```d
void remove(key_type item_key, Flag!"notifyChange" notifyChange = Yes.notifyChange);
void remove(T item);
void remove(A...)(A a);

```
**Summary:**
Removes an item from this and disconnects the signals. Notifies
that the length of this has changed.
 

***
```d
void add(T item, Flag!"notifyChange" notifyChange = Yes.notifyChange);
this(T item);
ref auto opOpAssign(string op)(T item) if (op == "~");

```
**Summary:**
Adds item to this and connects to the signals emitted by item.
Notifies that the length of this has changed.

Params |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want to add to this.|
*Flag!"notifyChange" notifyChange*|
&nbsp;&nbsp;&nbsp;&nbsp;whether or not to emit this change. Should only be No if coming from itemChanged|

:exclamation: **Throws:**
UniqueConstraintException if this already contains item and
    enforceConstraints is true.

:exclamation: **Throws:**
CheckConstraintException if the item is violating any of its
    defined check constraints and enforceConstraints is true.
 

***
```d
void add(T[] items);
this(T[] items);
ref auto opOpAssign(string op)(T[] items) if (op == "~");

```
**Summary:**
Does the same as add(T item) but for an array.
 

***
```d
inout ref inout(T) opIndex(in T item);

```
**Summary:**
Gets the approriate T that equals item.

Params |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want back from the collection.|

**Returns:**
The item in the collection that matches item.

:exclamation: **Throws:**
KeyedException if this does not contain a matching clustered index.
 

***
```d
inout ref inout(T) opIndex(in key_type clIdx);

```
**Summary:**
Gets the approriate T that has clustered index clIdx.

Params |
---|
*key_type clIdx*|
&nbsp;&nbsp;&nbsp;&nbsp;the clustered index of the item you want back.|

**Returns:**
The item in the collection that has clustered index clIdx.

:exclamation: **Throws:**
KeyedException if this does not contain a matching clustered index.
 

***
```d
inout ref inout(T) opIndex(A...)(in A a);

```
**Summary:**
Gets the approriate T that has clustered index a.

Params |
---|
*A a*|
&nbsp;&nbsp;&nbsp;&nbsp;the fields of the clustered index of the item you want back.|

**Returns:**
The item in the collection that has the clustered index with fields a.

:exclamation: **Throws:**
KeyedException if this does not contain a matching clustered index.
 

***
```d
auto opDispatch(string name, A...)(A a);

```
**Summary:**
Forwards all methods not specified by this abstract class
to the private associative array.
 

***
```d
int opApply(int delegate(ref T) dg);
int opApply(int delegate(key_type, ref T) dg);

```
**Summary:**
Allows you to use this in a foreach loop.
 

***
```d
const pure nothrow @property @safe size_t length();

```
**Summary:**
Gets the length of the collection.

**Returns:**
The number of items in the collection.
 

***
```d
const pure nothrow @nogc @safe bool contains(in T item);
inout pure nothrow @nogc @safe inout(T)* opBinaryRight(string op)(in T item) if (op == "in");

```
**Summary:**
Checks if item is in the collection.

Params |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want to see is in the collection.|

**Returns:**
true if item is in the collection.
 

***
```d
const pure nothrow @nogc @safe bool contains(in key_type clIdx);
inout pure nothrow @nogc @safe inout(T)* opBinaryRight(string op)(in key_type clIdx) if (op == "in");

```
**Summary:**
Checks if clIdx is in the collection.

Params |
---|
*key_type clIdx*|
&nbsp;&nbsp;&nbsp;&nbsp;the clustered index of the item you want
    to see is in the collection.|

**Returns:**
true if there is a clustered index in the collection that
    matches clIdx.
 

***
```d
const pure nothrow @nogc @safe bool contains(A...)(in A a);
inout pure nothrow @nogc @safe inout(T)* opBinaryRight(string op, A...)(in A a) if (op == "in");

```
**Summary:**
Checks if a makes a clustered index that is in the collection.

Params |
---|
*A a*|
&nbsp;&nbsp;&nbsp;&nbsp;the fields of the clustered index of the item you want
    to see is in the collection.|

**Returns:**
true if there is a clustered index in the collection that
    matches a.
 

***
```d
const pure nothrow bool violatesUniqueConstraints(in T item, out string constraintName);

```
**Summary:**
Checks if the item has any conflicting unique constraints. This
is more extensive than contains.
 





Page generated by [Ddoc](http://dlang.org/ddoc.html). 
