# db_extensions.keyed.keyedcollection
Generated by Ddoc from source/db_extensions/keyed/keyedcollection.d

***
```d
class BaseKeyedCollection(T) if (hasMember!(T, "dup") && hasMember!(T, "key") && hasMember!(T, "emitChange"));

```
**Summary:**
Turns the inheriting class into a base keyed collection.
The key is based on the singular class' clustered index.
T must have a dup property and a key property.
The clustered index and key are created when you include the keyeditem in your class.

Params |
---|
*T*|
&nbsp;&nbsp;&nbsp;&nbsp;the singular class.|

**Examples:**
```d

// singular class
class Candy
{
private:
    string _name;
    int _ranking;
    int _annualSales;
    string _brand;
public:
    // marking name as part of the primary key
    string name() const @property @PrimaryKeyColumn nothrow pure @safe @nogc
    {
        return _name;
    }
    void name(string value) @property
    {
        if (value != _name)
        {
            _name = value;
            notify("name");
        }
    }
    int ranking() const @property nothrow pure @safe @nogc
    {
        return _ranking;
    }
    void ranking(int value) @property
    {
        if (value != _ranking)
        {
            _ranking = value;
            notify("ranking");
        }
    }
    int annualSales() const @property nothrow pure @safe @nogc
    {
        return _annualSales;
    }
    void annualSales(int value) @property
    {
        if (value != _annualSales)
        {
            _annualSales = value;
            notify("annualSales");
        }
    }
    string brand() const @property nothrow pure @safe @nogc
    {
        return _brand;
    }
    void brand(string value) @property
    {
        if (value != _brand)
        {
            _brand = value;
            notify("brand");
        }
    }

    this(string name, immutable(int) ranking, immutable(int) annualSales, string brand)
    {
        this._name = name;
        this._ranking = ranking;
        this._annualSales = annualSales;
        this._brand = brand;
        // do not forget to set the clustered index
        setClusteredIndex();
    }
    Candy dup() const
    {
        return new Candy(this._name, this._ranking, this._annualSales, this._brand);
    }
    // the default is to make the primary key into the clustered index
    // which allows you to search based on the primary key
    mixin KeyedItem!(typeof(this));
}

// plural class
class Candies : BaseKeyedCollection!(Candy)
{
public:
    this(Candy[] items)
    {
        super(items);
    }
    this(Candy item)
    {
        super(item);
    }
}

// source: http://www.bloomberg.com/ss/09/10/1021_americas_25_top_selling_candies/
auto milkyWay = new Candy("Milkey Way", 18, 129_000_000, "Mars");
// should be Milky not Milkey, this is wrong on purpose
auto snickers = new Candy("Snickers", 4, 441_100_000, "Mars");
auto reesesPBCups = new Candy("Reese's Peanut Butter Cups", 2, 516_500_000, "Hershey");

auto mars = new Candies([milkyWay, snickers]);
assert(mars.length == 2);
assert(!mars.containsChanges);

// use the class as an index
assert(mars[milkyWay] == milkyWay);
// use the primary key as an index
auto pk = Candy.PrimaryKey("Milkey Way");
assert(mars[pk] == milkyWay);
// use the contents of the primary key as an index
assert(mars["Milkey Way"] == milkyWay);

// milky way is in mars
assert(pk in mars);
// reesesPBCups is not in mars
assert(!mars.contains(reesesPBCups));

// now we change the name to be correct
mars[pk].name = "Milky Way";
assert(mars.containsChanges);

// since we had name in pk spelled incorrectly
// and changed it, the primary key in mars has
// updated so Milkey Way is no longer in it but
// Milky Way is.
assert("Milkey Way" !in mars);
assert(mars.contains("Milky Way"));

foreach(name_pk, candy; mars)
{
    assert(mars[name_pk] == candy);
}

// trying to add another candy with the same name will
// result in a unique constraint violation
auto milkyWay2 = new Candy("Milky Way", 0, 0, "");
import std.exception : assertThrown;
assertThrown!(UniqueConstraintException)(mars ~= milkyWay2);

auto violatedConstraint = "";
assert(mars.isDuplicateItem(milkyWay2, violatedConstraint));
assert(violatedConstraint == "PrimaryKey");

// removing milky way from mars
mars.remove("Milky Way");
// this means milkyWay2 is no longer a duplicate
assert(!mars.isDuplicateItem(milkyWay2, violatedConstraint));


``` 
***
```d
alias key_type = typeof(T.key);

```
**Summary:**
The key type is alias'd at the type since it looked better than having
typeof(T.key) everywhere.
 

***
```d
pure nothrow @nogc @safe void markAsSaved();

```
**Summary:**
Changes this to not contain changes. Should only
be used after a save.
 

***
```d
const pure nothrow @nogc @property @safe bool containsChanges();

```
**Summary:**
Read-only property telling if this contains changes.

**Returns:**
true if this contains changes.
 

***
```d
const pure nothrow @nogc @property @safe bool enforceUniqueConstraints();
pure nothrow @nogc @property @safe void enforceUniqueConstraints(bool value);

```
**Summary:**
Getter and setter to enforce the unique constraints. By default
this is true but you may set it to false if you have a lot of
initial data and already trust that is unique.

**Description:**
Setting this to false means that there are no checks and if there
is a duplicate clustered index, it will be overwritten.
 

***
```d
void notify(string propertyName);

```
**Summary:**
Notifies this which property changed.
This also emits a signal with the property name that changed.

Params |
---|
*string propertyName*|
&nbsp;&nbsp;&nbsp;&nbsp;the property name that changed.|

 

***
```d
void remove(key_type item_key);
void remove(T item);
void remove(A...)(A a);

```
**Summary:**
Removes an item from this and disconnects the signals. Notifies
that the length of this has changed.
 

***
```d
void add(T item);
this(T item);
ref auto opOpAssign(string op)(T item) if (op == "~");

```
**Summary:**
Adds item to this and connects to the signals emitted by item.
Notifies that the length of this has changed.

Params |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want to add to this.|

:exclamation: **Throws:**
UniqueConstraintException if this already contains item and
    enforceUniqueConstraints is true.
 

***
```d
void add(T[] items);
this(T[] items);
ref auto opOpAssign(string op)(T[] items) if (op == "~");

```
**Summary:**
Adds items to this and connects to the signals emitted by each item.
Notifies that the length of this has changed.

Params |
---|
*T[] items*|
&nbsp;&nbsp;&nbsp;&nbsp;the items you want to add to this.|

:exclamation: **Throws:**
UniqueConstraintException if this already contains item.
 

***
```d
ref T opIndex(T item);

```
**Summary:**
Gets the approriate T that equals item.

Params |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want back from the collection.|

**Returns:**
The item in the collection that matches item.
 

***
```d
ref T opIndex(key_type clIdx);

```
**Summary:**
Gets the approriate T that has clustered index clIdx.

Params |
---|
*key_type clIdx*|
&nbsp;&nbsp;&nbsp;&nbsp;the clustered index of the item you want back.|

**Returns:**
The item in the collection that has clustered index clIdx.
 

***
```d
ref T opIndex(A...)(A a);

```
**Summary:**
Gets the approriate T that has clustered index a.

Params |
---|
*A a*|
&nbsp;&nbsp;&nbsp;&nbsp;the fields of the clustered index of the item you want back.|

**Returns:**
The item in the collection that has the clustered index with fields a.
 

***
```d
auto opDispatch(string name, A...)(A a);

```
**Summary:**
Forwards all methods not specified by this abstract class
to the private associative array.
 

***
```d
int opApply(int delegate(ref T) dg);
int opApply(int delegate(key_type, ref T) dg);

```
**Summary:**
Allows you to use this in a foreach loop.
 

***
```d
pure nothrow @property @safe size_t length();

```
**Summary:**
Gets the length of the collection.

**Returns:**
The number of items in the collection.
 

***
```d
pure nothrow @nogc @safe bool contains(T item);
pure nothrow @nogc @safe bool opBinaryRight(string op)(T item) if (op == "in");

```
**Summary:**
Checks if item is in the collection.

Params |
---|
*T item*|
&nbsp;&nbsp;&nbsp;&nbsp;the item you want to see is in the collection.|

**Returns:**
true if item is in the collection.
 

***
```d
pure nothrow @nogc @safe bool contains(key_type clIdx);
pure nothrow @nogc @safe bool opBinaryRight(string op)(key_type clIdx) if (op == "in");

```
**Summary:**
Checks if clIdx is in the collection.

Params |
---|
*key_type clIdx*|
&nbsp;&nbsp;&nbsp;&nbsp;the clustered index of the item you want
    to see is in the collection.|

**Returns:**
true if there is a clustered index in the collection that
    matches clIdx.
 

***
```d
pure nothrow @nogc @safe bool contains(A...)(A a);
pure nothrow @nogc @safe bool opBinaryRight(string op, A...)(A a) if (op == "in");

```
**Summary:**
Checks if a makes a clustered index that is in the collection.

Params |
---|
*A a*|
&nbsp;&nbsp;&nbsp;&nbsp;the fields of the clustered index of the item you want
    to see is in the collection.|

**Returns:**
true if there is a clustered index in the collection that
    matches a.
 

***
```d
bool isDuplicateItem(T item, out string constraintName);

```
**Summary:**
Checks if the item has any conflicting unique constraints. This
is more extensive than contains.
 





Page generated by [Ddoc](http://dlang.org/ddoc.html). 
