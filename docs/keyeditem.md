# db_constraints.keyed.keyeditem

[](Generated by Ddoc from source/db_constraints/keyed/keyeditem.d)

Keyed item is used in combination with KeyedCollection to mimic databases in your classes.
This module contains:
  + [KeyedItem](#KeyedItem)

**License:**
[GPL-2.0](https://github.com/marmy28/db_constraints/blob/master/LICENSE)


**Authors:**
Matthew Armbruster


**Source:** [source/db_constraints/keyed/keyeditem.d](https://github.com/marmy28/db_constraints/tree/master/source/db_constraints/keyed/keyeditem.d)



***

<a id="KeyedItem"></a>
```d
template KeyedItem(ClusteredIndexAttribute = PrimaryKeyColumn) if (isInstanceOf!(UniqueConstraintColumn, ClusteredIndexAttribute))
```

Use this in the singular class which would describe a row in your
database.

Parameters |
---|
*ClusteredIndexAttribute*|
&nbsp;&nbsp;&nbsp;&nbsp;the unique constraint associated with the clustered index.|


**Examples:**


```d

class Candy
{
private:
    string _name;
    int _ranking;
    string _brand;
public:
    // name is the primary key
    @PrimaryKeyColumn @NotNull
    @property string name() const nothrow pure @safe @nogc
    {
        return _name;
    }
    @property void name(string value)
    {
        setter(_name, value);
    }
    // ranking must be unique among all the other records
    @UniqueConstraintColumn!("uc_Candy_ranking")
    @property int ranking() const nothrow pure @safe @nogc
    {
        return _ranking;
    }
    // making sure that ranking will always be above 0
    @CheckConstraint!(a => a > 0, "chk_Candy_ranking")
    @property void ranking(int value)
    {
        setter(_ranking, value);
    }
    this(string name, immutable(int) ranking, string brand)
    {
        this._name = name;
        this._ranking = ranking;
        this._brand = brand;
        initializeKeyedItem();
    }

    // The primary key is now the clustered index as it is by default
    mixin KeyedItem!(PrimaryKeyColumn);
}

// source: http://www.bloomberg.com/ss/09/10/1021_americas_25_top_selling_candies/10.htm
auto i = new Candy("Opal Fruit", 17, "Mars");

assert(!i.containsChanges);

auto pk = Candy.PrimaryKey("Opal Fruit");
assert(i.key == pk);
assert(i.key == i.PrimaryKey_key);
assert(i.key.name == pk.name);

auto j = new Candy("Opal Fruit", 16, "");
// since name is the primary key i and j are equal because the names are equal
assert(i.key == j.key);

// in 1967 Opal Fruits came to America and changed its name
i.name = "Starburst";
assert(i.containsChanges);
i.markAsSaved();
assert(!i.containsChanges);

// by changing the name it also changes the primary key
assert(i.key != pk);
assert(i.key != j.key);

// below is what is created when you include the mixin KeyedItem
enum candyStructs =
`public:
final alias PrimaryKey = ClusteredIndex;
final alias PrimaryKey_key = key;
final struct uc_Candy_ranking
{
    typeof(Candy.ranking) ranking;
    mixin generic_compare!(uc_Candy_ranking);
}
final @property uc_Candy_ranking uc_Candy_ranking_key() const nothrow pure @safe @nogc
{
    auto _uc_Candy_ranking_key = uc_Candy_ranking();
    _uc_Candy_ranking_key.ranking = this._ranking;
    return _uc_Candy_ranking_key;
}
`;
import db_constraints.utils.meta : ConstraintStructs;
static assert(ConstraintStructs!(Candy, "PrimaryKey") == candyStructs);
assert(ConstraintStructs!(Candy, "PrimaryKey") == candyStructs);

import std.exception : assertThrown;
import db_constraints.db_exceptions : CheckConstraintException;
// we expect setting the ranking to 0 will result in an exception
// since we labeled that column with
// @CheckConstraint!(a => a > 0, "chk_Candy_ranking")
assertThrown!CheckConstraintException(i.ranking = 0);

```

***

<a id="KeyedItem.containsChanges"></a>
```d
final const pure nothrow @nogc @property @safe bool containsChanges();

```

Read-only property telling if `this` contains changes.

**Returns:**
true if `this` contains changes.


***

<a id="KeyedItem.markAsSaved"></a>
```d
final pure nothrow @nogc @safe void markAsSaved();

```

Changes `this` to not contain changes. Should only
be used after a save.


***

<a id="KeyedItem.notify"></a>
```d
final void notify(string propertyName);

```

Notifies `this` which property changed. If the property is
part of the clustered index then the clustered index is updated.
This also emits a signal with the property name that changed
along with the clustered index.

Parameters |
---|
*string propertyName*|
&nbsp;&nbsp;&nbsp;&nbsp;the property name that changed|



***

<a id="KeyedItem.ClusteredIndex"></a>
```d
struct ClusteredIndex;

```

Clustered index struct created at compile-time.
This is used to compare classes. The members
are the members of the class marked with the
attribute selected as the Clustered Index.


***

<a id="KeyedItem.key"></a>
```d
final const pure nothrow @nogc @property @safe ClusteredIndex key();

```

The clustered index property for the class.

**Returns:**
The clustered index for the class.


***

<a id="KeyedItem.setClusteredIndex"></a>
```d
final pure nothrow @nogc @safe void setClusteredIndex();

```

Sets the clustered index for `this`.






Copyright :copyright: 2015 | Page generated by [Ddoc](http://dlang.org/ddoc.html) on Sat Oct 10 10:04:12 2015

