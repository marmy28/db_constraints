# db_extensions.keyed.keyeditem
Generated by Ddoc from source/db_extensions/keyed/keyeditem.d

***
```d
template KeyedItem(T, ClusteredIndexAttribute = PrimaryKeyColumn) if (is(T == class))
```
**Summary:**
Use this in the singular class which would describe a row in your
database.

Params |
---|
*T*|
&nbsp;&nbsp;&nbsp;&nbsp;the type of the class this is mixed into.|
*ClusteredIndexAttribute*|
&nbsp;&nbsp;&nbsp;&nbsp;the attribute associated with the clustered index.|

**Examples:**
```d

class Candy
{
private:
    string _name;
    int _ranking;
    string _brand;
public:
    string name() const @property @PrimaryKeyColumn nothrow pure @safe @nogc
    {
        return _name;
    }
    void name(string value) @property
    {
        if (value != _name)
        {
            _name = value;
            notify("name");
        }
    }
    int ranking() const @property nothrow pure @safe @nogc @UniqueConstraintColumn!("uc_Candy_ranking")
    {
        return _ranking;
    }
    void ranking(int value) @property
    {
        if (value != _ranking)
        {
            _ranking = value;
            notify("ranking");
        }
    }
    string brand() const @property nothrow pure @safe @nogc
    {
        return _brand;
    }
    void brand(string value) @property
    {
        if (value != _brand)
        {
            _brand = value;
            notify("brand");
        }
    }
    this()
    {
        this._name = string.init;
        this._ranking = int.init;
        this._brand = string.init;
        setClusteredIndex();
    }

    this(string name, immutable(int) ranking, string brand)
    {
        this._name = name;
        this._ranking = ranking;
        this._brand = brand;
        // do not forget to set the clustered index
        setClusteredIndex();
    }
    Candy dup() const
    {
        return new Candy(this._name, this._ranking, this._brand);
    }
    // The primary key is now the clustered index
    mixin KeyedItem!(typeof(this), PrimaryKeyColumn);
}

// source: http://www.bloomberg.com/ss/09/10/1021_americas_25_top_selling_candies/10.htm
auto i = new Candy("Opal Fruit", 17, "Mars");

assert(!i.containsChanges);

auto pk = Candy.PrimaryKey("Opal Fruit");
assert(i.key == pk);
assert(i.key == i.PrimaryKey_key);
assert(i.key.name == pk.name);

auto j = new Candy("Opal Fruit", 0, "");
// since name is the clustered index i and j are equal because the names are equal
assert(i == j);

// in 1967 Opal Fruits came to America and changed its name
i.name = "Starburst";
assert(i.containsChanges);
i.markAsSaved();
assert(!i.containsChanges);

// by changing the name it also changes the primary key
assert(i.key != pk);
assert(i != j);

// below is what is created when you include the mixin KeyedItem
enum candyStructs =
`public:
alias PrimaryKey = ClusteredIndex;
alias PrimaryKey_key = key;
struct uc_Candy_ranking
{
    typeof\(Candy.ranking\) ranking;
    import db_extensions.keyed.generickey;
    mixin generic_compare!\(uc_Candy_ranking\);
}
uc_Candy_ranking uc_Candy_ranking_key\(\) const @property nothrow pure @safe @nogc
{
    auto _uc_Candy_ranking_key = uc_Candy_ranking\(\);
    _uc_Candy_ranking_key.ranking = this._ranking;
    return _uc_Candy_ranking_key;
}
`;
static assert(Candy.createType!(Candy.stringof) == candyStructs);


``` 
***
```d
pure nothrow @nogc @property @safe bool containsChanges();

```
**Summary:**
Read-only property telling if this contains changes.

**Returns:**
true if this contains changes.
 

***
```d
pure nothrow @nogc @safe void markAsSaved();

```
**Summary:**
Changes this to not contain changes. Should only
be used after a save.
 

***
```d
void notify(string propertyName);

```
**Summary:**
Notifies this which property changed. If the property is
part of the clustered index then the clustered index is updated.
This also emits a signal with the property name that changed
along with the clustered index.

Params |
---|
*string propertyName*|
&nbsp;&nbsp;&nbsp;&nbsp;the property name that changed.|

 

***
```d
struct ClusteredIndex;

```
**Summary:**
Clustered index struct created at compile-time.
This is used to compare classes. The members
are the members of the class marked with the
attribute selected as the Clustered Index.
 

***
```d
const pure nothrow @nogc @property @safe ClusteredIndex key();

```
**Summary:**
The clustered index property for the class.

**Returns:**
The clustered index for the class.
 

***
```d
pure nothrow @nogc @safe void setClusteredIndex();

```
**Summary:**
Sets the clustered index for this.
 

***
```d
const pure nothrow @nogc bool opEquals(Object o);

```
**Summary:**
Compares this based on the clustered index.

**Returns:**
true if the clustered index equal.
 

***
```d
const int opCmp(Object o);

```
**Summary:**
Compares this based on the clustered index if comparison is with the same class.

**Returns:**
The comparison from the clustered index.
 

***
```d
const nothrow @safe size_t toHash();

```
**Summary:**
Gets the hash of the clustered index.

**Returns:**
The hash of the clustered index.
 





Page generated by [Ddoc](http://dlang.org/ddoc.html). 
