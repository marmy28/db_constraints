# db_constraints.keyed.keyeditem
Generated by Ddoc from source/db_constraints/keyed/keyeditem.d

***
```d
template KeyedItem(T, ClusteredIndexAttribute = PrimaryKeyColumn) if (is(T == class))
```
**Summary:**
Use this in the singular class which would describe a row in your
database.

Params |
---|
*T*|
&nbsp;&nbsp;&nbsp;&nbsp;the type of the class this is mixed into.|
*ClusteredIndexAttribute*|
&nbsp;&nbsp;&nbsp;&nbsp;the attribute associated with the clustered index.|

**Examples:**
```d

class Candy
{
private:
    string _name;
    int _ranking;
    string _brand;
public:
    // name is the primary key
    @PrimaryKeyColumn
    string name() const @property nothrow pure @safe @nogc
    {
        return _name;
    }
    void name(string value) @property
    {
        setter(_name, value);
    }
    // ranking must be unique among all the other records
    @UniqueConstraintColumn!("uc_Candy_ranking")
    int ranking() const @property nothrow pure @safe @nogc
    {
        return _ranking;
    }
    // making sure that ranking will always be above 0
    @CheckConstraint!(a => a > 0, "chk_Candy_ranking")
    void ranking(int value) @property
    {
        setter(_ranking, value);
    }
    string brand() const @property nothrow pure @safe @nogc
    {
        return _brand;
    }
    void brand(string value) @property
    {
        setter(_brand, value);
    }
    this(string name, immutable(int) ranking, string brand)
    {
        this._name = name;
        this._ranking = ranking;
        this._brand = brand;
        initializeKeyedItem();
    }
    Candy dup() const
    {
        return new Candy(this._name, this._ranking, this._brand);
    }

    // The primary key is now the clustered index as it is by default
    mixin KeyedItem!(typeof(this), PrimaryKeyColumn);
}

// source: http://www.bloomberg.com/ss/09/10/1021_americas_25_top_selling_candies/10.htm
auto i = new Candy("Opal Fruit", 17, "Mars");

assert(!i.containsChanges);

auto pk = Candy.PrimaryKey("Opal Fruit");
assert(i.key == pk);
assert(i.key == i.PrimaryKey_key);
assert(i.key.name == pk.name);

auto j = new Candy("Opal Fruit", 16, "");
// since name is the primary key i and j are equal because the names are equal
assert(i.key == j.key);

// in 1967 Opal Fruits came to America and changed its name
i.name = "Starburst";
assert(i.containsChanges);
i.markAsSaved();
assert(!i.containsChanges);

// by changing the name it also changes the primary key
assert(i.key != pk);
assert(i.key != j.key);

// below is what is created when you include the mixin KeyedItem
enum candyStructs =
`public:
alias PrimaryKey = ClusteredIndex;
alias PrimaryKey_key = key;
struct uc_Candy_ranking
{
    typeof(Candy.ranking) ranking;
    mixin generic_compare!(uc_Candy_ranking);
}
uc_Candy_ranking uc_Candy_ranking_key() const @property nothrow pure @safe @nogc
{
    auto _uc_Candy_ranking_key = uc_Candy_ranking();
    _uc_Candy_ranking_key.ranking = this._ranking;
    return _uc_Candy_ranking_key;
}
`;
assert(Candy.createType!(Candy.stringof) == candyStructs);

import std.exception : assertThrown;
import db_constraints.db_exceptions : CheckConstraintException;
// we expect setting the ranking to 0 will result in an exception
// since we labeled that column with
// @CheckConstraint!(a => a > 0, "chk_Candy_ranking")
assertThrown!CheckConstraintException(i.ranking = 0);


``` 
***
```d
final const pure nothrow @nogc @property @safe bool containsChanges();

```
**Summary:**
Read-only property telling if this contains changes.

**Returns:**
true if this contains changes.
 

***
```d
final pure nothrow @nogc @safe void markAsSaved();

```
**Summary:**
Changes this to not contain changes. Should only
be used after a save.
 

***
```d
final void notify(string propertyName)();

```
**Summary:**
Notifies this which property changed. If the property is
part of the clustered index then the clustered index is updated.
This also emits a signal with the property name that changed
along with the clustered index.

Params |
---|
*propertyName*|
&nbsp;&nbsp;&nbsp;&nbsp;the property name that changed.|

 

***
```d
struct ClusteredIndex;

```
**Summary:**
Clustered index struct created at compile-time.
This is used to compare classes. The members
are the members of the class marked with the
attribute selected as the Clustered Index.
 

***
```d
final const pure nothrow @nogc @property @safe ClusteredIndex key();

```
**Summary:**
The clustered index property for the class.

**Returns:**
The clustered index for the class.
 

***
```d
final pure nothrow @nogc @safe void setClusteredIndex();

```
**Summary:**
Sets the clustered index for this.
 





Page generated by [Ddoc](http://dlang.org/ddoc.html). 
